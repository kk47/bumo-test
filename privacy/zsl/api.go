package zsl

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"io/ioutil"
	"strings"

	"github.com/jpmorganchase/zsl-q/zsl-golang/zsl/snark"
	"github.com/ethereum/go-ethereum/common"
)

const (
	ZSL_PROOF_SIZE int = 584
	ZSL_TREE_DEPTH     = 29
)

type PublicZSLAPI struct {
}

func NewPublicZSLAPI() *PublicZSLAPI {
	return &PublicZSLAPI{}
}

// Note: API function names should match those defined in web3ext.go, first character upper case as external function.

func (api *PublicZSLAPI) LoadTracker(filename string) (string, error) {
	data, err := ioutil.ReadFile(filename)
	return string(data[:]), err
}

// TODO: Post-demo, sanitize filenames and check exiting files before over-writing.
func (api *PublicZSLAPI) SaveTracker(filename string, data string) bool {
	b := []byte(data)
	err := ioutil.WriteFile(filename, b, 0644)
	return err == nil
}

// Convert proof hex string from javascript to correct format.  Trims leading 0x if present.
func getProofFromHex(s string) ([ZSL_PROOF_SIZE]byte, error) {
	var proof [ZSL_PROOF_SIZE]byte

	buf, err := hex.DecodeString(strings.TrimPrefix(s, "0x"))
	if err != nil {
		return proof, err
	}

	proofSize := len(buf)
	if proofSize != ZSL_PROOF_SIZE {
		return proof, errors.New(fmt.Sprintf("ZSL error, proof must have size of %d bytes, not %d.\n", ZSL_PROOF_SIZE, proofSize))
	}

	copy(proof[:], buf[:ZSL_PROOF_SIZE])
	return proof, nil
}

// send nullifier, SHA256(0x00 || rho)
func computeSendNullifier(rho []byte) []byte {
	h := sha256.New()
	h.Write([]byte{0x00})
	h.Write(rho)
	return h.Sum(nil)
}

// spend nullifier SHA256(0x01 || rho || sk)
func computeSpendNullifier(rho []byte, sk [32]byte) []byte {
	h := sha256.New()
	h.Write([]byte{0x01})
	h.Write(rho)
	h.Write(sk[:])
	return h.Sum(nil)
}

// spend nullifier SHA256(0x01 || rho || sk || addr)
func computeSpendNullifierAuthenticated(rho []byte, sk [32]byte, addr [20]byte) []byte {
	h := sha256.New()
	h.Write([]byte{0x01})
	h.Write(rho)
	h.Write(sk[:])
	h.Write(addr[:])
	return h.Sum(nil)
}

// cm = SHA256(rho || pk || v) where v is in little endian byte order
func computeCommitment(rho [32]byte, pk [32]byte, v uint64) []byte {
	vbuf := make([]byte, 8)
	binary.LittleEndian.PutUint64(vbuf, v)

	h := sha256.New()
	h.Write(rho[:])
	h.Write(pk[:])
	h.Write(vbuf)
	return h.Sum(nil)
}

func (api *PublicZSLAPI) GetCommitment(rho common.Hash, pk common.Hash, value float64) common.Hash {
	return common.BytesToHash(computeCommitment(rho, pk, uint64(value)))
}

func (api *PublicZSLAPI) GetSendNullifier(rho common.Hash) common.Hash {
	return common.BytesToHash(computeSendNullifier(rho[:]))
}

func (api *PublicZSLAPI) GetSpendNullifier(rho common.Hash, sk common.Hash) common.Hash {
	return common.BytesToHash(computeSpendNullifier(rho[:], sk))
}

/**
Example to generate a proof in geth:

sk = "0xf0f0f0f00f0f0ffffffffff000000f0f0f0f0f00f0000f0f00f00f0f0f0f00ff"
pk = "0xe8e55f617b4b693083f883f70926dd5673fa434cefa3660828759947e2276348"
rho = "0xdedeffdddedeffdddedeffdddedeffdddedeffdddedeffdddedeffdddedeffdd"
value = 2378237
zsl.createShielding(rho, pk, value);

Results in:
cm = "0x58e38183982c6f7981e9f3ce0a735fdd4ca2f0cd88db6ee608c2fe1e84142d0d"
send_nf = "0xc813e257232fae0fee5244aadf98d7ab7a676724c128cd3c0d52d3a01739a3da"
*/
func (api *PublicZSLAPI) CreateShielding(rho common.Hash, pk common.Hash, value float64) (map[string]interface{}, error) {
	result := make(map[string]interface{})

	snark.Init()
	proof := snark.ProveShielding(rho, pk, uint64(value))
	send_nf := computeSendNullifier(rho[:])
	cm := computeCommitment(rho, pk, uint64(value))
	result["proof"] = "0x" + hex.EncodeToString(proof[:])
	result["cm"] = common.BytesToHash(cm)
	result["send_nf"] = common.BytesToHash(send_nf)
	return result, nil
}

/**
Continuing example above...
ztoken.addCommitment(cm, {from:eth.accounts[0], gas:470000})
rt = ztoken.root()
treeIndex = ztoken.getWitness(cm)[0]
authPath = ztoken.getWitness(cm)[1]
zsl.createUnshielding(rho, sk, value, treeIndex, authPath)
Verify with:
zsl.verifyUnshielding(proof, spend_nf, rt, value)
*/
func (api *PublicZSLAPI) CreateUnshielding(rho common.Hash, sk common.Hash, addr common.Address, value float64, treeIndex float64, authPath []string) (map[string]interface{}, error) {
	result := make(map[string]interface{})

	// copy authentication path array into two dimensional array (as required by snark.ProveUnshielding())
	if len(authPath) != ZSL_TREE_DEPTH {
		return result, errors.New(fmt.Sprintf("Authentiction path must be %d in length", ZSL_TREE_DEPTH))
	}
	var authenticationPath [ZSL_TREE_DEPTH][32]byte
	for i := 0; i < ZSL_TREE_DEPTH; i++ {
		b, err := hex.DecodeString(strings.TrimPrefix(authPath[i], "0x"))
		if err != nil {
			return result, err
		}
		var uncle [32]byte
		copy(uncle[:], b[:32])
		authenticationPath[i] = uncle
	}

	snark.Init()
	proof := snark.ProveUnshielding(rho, sk, addr, uint64(value), uint64(treeIndex), authenticationPath)
	send_nf := computeSendNullifier(rho[:])
	spend_nf := computeSpendNullifierAuthenticated(rho[:], sk, addr)
	result["proof"] = "0x" + hex.EncodeToString(proof[:])
	result["send_nf"] = common.BytesToHash(send_nf)
	result["spend_nf"] = common.BytesToHash(spend_nf)
	return result, nil
}

/*
    Dummy inputs:
	sk = "0xf0f0f0f00f0f0ffffffffff000000f0f0f0f0f00f0000f0f00f00f0f0f0f00ff";
   	pk = "0xe8e55f617b4b693083f883f70926dd5673fa434cefa3660828759947e2276348";
   	rho = "0xdedeffdddedeffdddedeffdddedeffdddedeffdddedeffdddedeffdddedeffdd";
   	val = 2378237;
   	uncles = ["0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100","0x8000000000000000000000000000000000000000000000000000000000000100"]
	Dummy outputs:
	o_rho = "0xfbacfbacfbacfbacfbacfbacfbacfbacfbacfbacfbacfbacfbacfbacfbacfbac";
    o_pk = "0xacfbacfbacfbacfbacfbacfbacfbacfbacfbacfbacfbacfbacfbacfbacfbacfb";
	o_val = 2378237;
	Dummy anchor:
	anchor = "0x8610652739ac0c6bb6b5353649bb822b26543f0ebe88f32a489a56843cd04f03";

	Result:
	{
	in_spend_nf_1: "0x45ccb210613318d0d127e9947c2ce6b1b246c5c2dd53489c1f39397843410c1a",
	in_spend_nf_2: "0x45ccb210613318d0d127e9947c2ce6b1b246c5c2dd53489c1f39397843410c1a",
	out_cm_1: "0xd6218a07714dd9fac92bdeefd3f4c0d769f40f4b043ad7e67e7375edc498e45c",
	out_cm_2: "0xd6218a07714dd9fac92bdeefd3f4c0d769f40f4b043ad7e67e7375edc498e45c",
	out_send_nf_1: "0x35f7ff845e4786d644c9c905fe68fd0f602fea0beb2c341bc5d2defc17c32e86",
	out_send_nf_2: "0x35f7ff845e4786d644c9c905fe68fd0f602fea0beb2c341bc5d2defc17c32e86",
	proof: "0x301fbec0db39fb81073593813ae45a2031588e3937181fbbb698cd8df2142ac426acb739456f2ea1561b352bb562b9af4835cd7a2f8943440ab014b5b98c6edf0730f645add2ac7940fa32d2bc097b81353193a1ca58fd30ec81fad3eec7acfcca1c2f1c0291b8b5d0fd22819262a15a2d71e92ac04ebb469fa29e43c5cd6b7de40730e7e92d6da23f93d575444eddd38c89fdec8f94a6294afef4aa9da9c2f20035141cf4efb334c820d5e0a98ffe01492e7dba547cf433d7e8521ed3e7aaec64a20f96d60b2c23d0ba18f0ac383ae186caa3f445dc522c21d4f6a0a931933729c210c57f8c6a1d51fce2e2d0cc5cb6b3afbdbfb922d158fa85bdc78b9dbc44d78e12306d1b53090d8937e79cd58f544131ad56b11806cb60c1fa759674dc2c3dde4b041370ea7a21c4ba6f64b03b2d7fc57ae609b09685a5c61b9048a84dbf768bc92b304fe96c28c7b59093fad132f7c259a41f0318203e6fa8c3d00b2fc72605c3120bd270ab8a548caf964457cf48256cb95238ce0faa021c7c5e821d0974289e602430711fec13a9b59a3f6bd805e12561730dce6c72de82b7b6a817d26c6608e0ad1ec88185e209d12512c44f86692eae0b8316f516192ce513471644d5a31bfde01d303a2c3de7c50316adf5b84d0014a17c46f479d7ed75e2458a785958011601e9088013ad9b663738a830c5cbfe8c95424eb26bf5d5aaa6b71f7bdfe4735494c50630658ed6d800d7ad42810e500f8713fef2447a39b71062f2bbcc996c19b2892c2f6ae038042c418d2610acf0a7a571a5a7d1d0a18b0769e92b6c50d72204c8df1d"
	}
*/
func (api *PublicZSLAPI) CreateShieldedTransfer(
	rho_1 common.Hash, sk_1 common.Hash, value_1 float64, treeIndex_1 float64, authPath_1 []string,
	rho_2 common.Hash, sk_2 common.Hash, value_2 float64, treeIndex_2 float64, authPath_2 []string,
	out_rho_1 common.Hash, out_pk_1 common.Hash, out_value_1 float64,
	out_rho_2 common.Hash, out_pk_2 common.Hash, out_value_2 float64,
) (map[string]interface{}, error) {

	result := make(map[string]interface{})

	// copy authentication path array into two dimensional array (as required by snark.ProveUnshielding())
	if len(authPath_1) != ZSL_TREE_DEPTH {
		return result, errors.New(fmt.Sprintf("Authentication path 1 must be %d in length", ZSL_TREE_DEPTH))
	}
	var authenticationPath_1 [ZSL_TREE_DEPTH][32]byte
	for i := 0; i < ZSL_TREE_DEPTH; i++ {
		b, err := hex.DecodeString(strings.TrimPrefix(authPath_1[i], "0x"))
		if err != nil {
			return result, err
		}
		var uncle [32]byte
		copy(uncle[:], b[:32])
		authenticationPath_1[i] = uncle
	}

	if len(authPath_2) != ZSL_TREE_DEPTH {
		return result, errors.New(fmt.Sprintf("Authentication path 2 must be %d in length", ZSL_TREE_DEPTH))
	}
	var authenticationPath_2 [ZSL_TREE_DEPTH][32]byte
	for i := 0; i < ZSL_TREE_DEPTH; i++ {
		b, err := hex.DecodeString(strings.TrimPrefix(authPath_2[i], "0x"))
		if err != nil {
			return result, err
		}
		var uncle [32]byte
		copy(uncle[:], b[:32])
		authenticationPath_2[i] = uncle
	}

	snark.Init()
	proof := snark.ProveTransfer(
		rho_1, sk_1, uint64(value_1), uint64(treeIndex_1), authenticationPath_1,
		rho_2, sk_2, uint64(value_2), uint64(treeIndex_2), authenticationPath_2,
		out_rho_1, out_pk_1, uint64(out_value_1),
		out_rho_2, out_pk_2, uint64(out_value_2),
	)

	send_nf_1 := computeSendNullifier(out_rho_1[:])
	send_nf_2 := computeSendNullifier(out_rho_2[:])
	spend_nf_1 := computeSpendNullifier(rho_1[:], sk_1)
	spend_nf_2 := computeSpendNullifier(rho_2[:], sk_2)
	cm_1 := computeCommitment(out_rho_1, out_pk_1, uint64(out_value_1))
	cm_2 := computeCommitment(out_rho_2, out_pk_2, uint64(out_value_2))
	result["proof"] = "0x" + hex.EncodeToString(proof[:])
	result["out_send_nf_1"] = common.BytesToHash(send_nf_1)
	result["out_send_nf_2"] = common.BytesToHash(send_nf_2)
	result["in_spend_nf_1"] = common.BytesToHash(spend_nf_1)
	result["in_spend_nf_2"] = common.BytesToHash(spend_nf_2)
	result["out_cm_1"] = common.BytesToHash(cm_1)
	result["out_cm_2"] = common.BytesToHash(cm_2)
	return result, nil
}

// geth: zsl.verifyShielding(proof, send_nf, cm, value);
// Javascript numbers are floats, there is no support for 64-bit integers.
func (api *PublicZSLAPI) VerifyShielding(proofHex string, send_nf common.Hash, cm common.Hash, value float64) (bool, error) {

	proof, err := getProofFromHex(proofHex)
	if err != nil {
		return false, err
	}

	snark.Init()
	result := snark.VerifyShielding(proof, send_nf, cm, uint64(value))
	return result, nil
}

// geth: zsl.verifyUnshielding(proof, spend_nf, rt, addr, value);
// Javascript numbers are floats, there is no support for 64-bit integers.
func (api *PublicZSLAPI) VerifyUnshielding(proofHex string, spend_nf common.Hash, rt common.Hash, addr common.Address, value float64) (bool, error) {

	proof, err := getProofFromHex(proofHex)
	if err != nil {
		return false, err
	}

	snark.Init()
	result := snark.VerifyUnshielding(proof, spend_nf, rt, addr, uint64(value))
	return result, nil
}

func (api *PublicZSLAPI) VerifyShieldedTransfer(
	proofHex string,
	anchor common.Hash,
	spend_nf_1 common.Hash,
	spend_nf_2 common.Hash,
	send_nf_1 common.Hash,
	send_nf_2 common.Hash,
	cm_1 common.Hash,
	cm_2 common.Hash) (bool, error) {

	proof, err := getProofFromHex(proofHex)
	if err != nil {
		return false, err
	}

	snark.Init()
	result := snark.VerifyTransfer(proof, anchor, spend_nf_1, spend_nf_2, send_nf_1, send_nf_2, cm_1, cm_2)
	return result, nil
}

// Generate 32 bytes of randomness for use with private contracts i.e. r_alice, r_bob.
func (api *PublicZSLAPI) GetRandomness() (common.Hash, error) {
	buf := make([]byte, 32)
	_, err := rand.Read(buf)
	if err != nil {
		return common.BytesToHash(buf), err
	}
	return common.BytesToHash(buf), nil
}

// Create a shielded address and return all components: a_sk, a_pk
func (api *PublicZSLAPI) GetNewAddress() (map[string]interface{}, error) {
	result := make(map[string]interface{})
	buf := make([]byte, 32)
	_, err := rand.Read(buf)
	if err != nil {
		return result, err
	}
	result["a_sk"] = common.BytesToHash(buf)
	apk := sha256.Sum256(buf)
	result["a_pk"] = common.BytesToHash(apk[:])
	return result, nil
}

// Test copied from from snark_test.go
func (api *PublicZSLAPI) DebugShielding() (bool, error) {

	snark.Init()

	proof := snark.ProveShielding(
		[32]byte{0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac},
		[32]byte{0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb},
		2378237)

	result := snark.VerifyShielding(proof,
		[32]byte{0x35, 0xf7, 0xff, 0x84, 0x5e, 0x47, 0x86, 0xd6, 0x44, 0xc9, 0xc9, 0x05, 0xfe, 0x68, 0xfd, 0x0f, 0x60, 0x2f, 0xea, 0x0b, 0xeb, 0x2c, 0x34, 0x1b, 0xc5, 0xd2, 0xde, 0xfc, 0x17, 0xc3, 0x2e, 0x86},
		[32]byte{0xd6, 0x21, 0x8a, 0x07, 0x71, 0x4d, 0xd9, 0xfa, 0xc9, 0x2b, 0xde, 0xef, 0xd3, 0xf4, 0xc0, 0xd7, 0x69, 0xf4, 0x0f, 0x4b, 0x04, 0x3a, 0xd7, 0xe6, 0x7e, 0x73, 0x75, 0xed, 0xc4, 0x98, 0xe4, 0x5c},
		2378237)
	if !result {
		return false, errors.New("proof was not invalid as expected")
	}

	result = snark.VerifyShielding(proof,
		[32]byte{0x35, 0xf7, 0xff, 0x84, 0x5e, 0x47, 0x86, 0xd6, 0x44, 0xc9, 0xc9, 0x05, 0xfe, 0x68, 0xfd, 0x0f, 0x60, 0x2f, 0xea, 0x0b, 0xeb, 0x2c, 0x34, 0x1b, 0xc5, 0xd2, 0xde, 0xfc, 0x17, 0xc3, 0x2e, 0x86},
		[32]byte{0xd6, 0x21, 0x8a, 0x07, 0x71, 0x4d, 0xd9, 0xfa, 0xc9, 0x2b, 0xde, 0xef, 0xd3, 0xf4, 0xc0, 0xd7, 0x69, 0xf4, 0x0f, 0x4b, 0x04, 0x3a, 0xd7, 0xe6, 0x7e, 0x73, 0x75, 0xed, 0xc4, 0x98, 0xe4, 0x5c},
		2378236)
	if result {
		return false, errors.New("proof was not invalid as expected")
	}

	result = snark.VerifyShielding(proof,
		[32]byte{0x34, 0xf7, 0xff, 0x84, 0x5e, 0x47, 0x86, 0xd6, 0x44, 0xc9, 0xc9, 0x05, 0xfe, 0x68, 0xfd, 0x0f, 0x60, 0x2f, 0xea, 0x0b, 0xeb, 0x2c, 0x34, 0x1b, 0xc5, 0xd2, 0xde, 0xfc, 0x17, 0xc3, 0x2e, 0x86},
		[32]byte{0xd6, 0x21, 0x8a, 0x07, 0x71, 0x4d, 0xd9, 0xfa, 0xc9, 0x2b, 0xde, 0xef, 0xd3, 0xf4, 0xc0, 0xd7, 0x69, 0xf4, 0x0f, 0x4b, 0x04, 0x3a, 0xd7, 0xe6, 0x7e, 0x73, 0x75, 0xed, 0xc4, 0x98, 0xe4, 0x5c},
		2378237)
	if result {
		return false, errors.New("proof was not invalid as expected")
	}

	return true, nil
}

// Test copied from from snark_test.go
func (api *PublicZSLAPI) DebugUnshielding() (bool, error) {

	snark.Init()

	proof := snark.ProveUnshielding(
		[32]byte{0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd},
		[32]byte{0xf0, 0xf0, 0xf0, 0xf0, 0x0f, 0x0f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0xf0, 0x00, 0x0f, 0x0f, 0x00, 0xf0, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0xff},
		[20]byte{0xed, 0x9d, 0x02, 0xe3, 0x82, 0xb3, 0x48, 0x18, 0xe8, 0x8b, 0x88, 0xa3, 0x09, 0xc7, 0xfe, 0x71, 0xe6, 0x5f, 0x41, 0x9d},
		2378237,
		0,
		[29][32]byte{
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00}})

	result := snark.VerifyUnshielding(proof,
		[32]byte{0x3a, 0x2c, 0xeb, 0xa3, 0x2e, 0xf0, 0x24, 0x56, 0xd5, 0x19, 0xf0, 0x66, 0xe6, 0xb6, 0xf8, 0xa2, 0x72, 0xb6, 0x88, 0x4a, 0xb5, 0x73, 0x61, 0x58, 0xc6, 0x30, 0x8e, 0x04, 0x38, 0x2a, 0x78, 0xaf},
		[32]byte{0x86, 0x10, 0x65, 0x27, 0x39, 0xac, 0x0c, 0x6b, 0xb6, 0xb5, 0x35, 0x36, 0x49, 0xbb, 0x82, 0x2b, 0x26, 0x54, 0x3f, 0x0e, 0xbe, 0x88, 0xf3, 0x2a, 0x48, 0x9a, 0x56, 0x84, 0x3c, 0xd0, 0x4f, 0x03},
		[20]byte{0xed, 0x9d, 0x02, 0xe3, 0x82, 0xb3, 0x48, 0x18, 0xe8, 0x8b, 0x88, 0xa3, 0x09, 0xc7, 0xfe, 0x71, 0xe6, 0x5f, 0x41, 0x9d},
		2378237)
	if !result {
		return false, errors.New("proof was not valid as expected")
	}

	result = snark.VerifyUnshielding(proof,
		[32]byte{0x3a, 0x2c, 0xeb, 0xa3, 0x2e, 0xf0, 0x24, 0x56, 0xd5, 0x19, 0xf0, 0x66, 0xe6, 0xb6, 0xf8, 0xa2, 0x72, 0xb6, 0x88, 0x4a, 0xb5, 0x73, 0x61, 0x58, 0xc6, 0x30, 0x8e, 0x04, 0x38, 0x2a, 0x78, 0xaf},
		[32]byte{0x86, 0x10, 0x65, 0x27, 0x39, 0xac, 0x0c, 0x6b, 0xb6, 0xb5, 0x35, 0x36, 0x49, 0xbb, 0x82, 0x2b, 0x26, 0x54, 0x3f, 0x0e, 0xbe, 0x88, 0xf3, 0x2a, 0x48, 0x9a, 0x56, 0x84, 0x3c, 0xd0, 0x4f, 0x03},
		[20]byte{0xed, 0x9d, 0x02, 0xe3, 0x82, 0xb3, 0x48, 0x18, 0xe8, 0x8b, 0x88, 0xa3, 0x09, 0xc7, 0xfe, 0x71, 0xe6, 0x5f, 0x41, 0x9d},
		2378236)
	if result {
		return false, errors.New("proof was not invalid as expected")
	}

	result = snark.VerifyUnshielding(proof,
		[32]byte{0x39, 0x2c, 0xeb, 0xa3, 0x2e, 0xf0, 0x24, 0x56, 0xd5, 0x19, 0xf0, 0x66, 0xe6, 0xb6, 0xf8, 0xa2, 0x72, 0xb6, 0x88, 0x4a, 0xb5, 0x73, 0x61, 0x58, 0xc6, 0x30, 0x8e, 0x04, 0x38, 0x2a, 0x78, 0xaf},
		[32]byte{0x86, 0x10, 0x65, 0x27, 0x39, 0xac, 0x0c, 0x6b, 0xb6, 0xb5, 0x35, 0x36, 0x49, 0xbb, 0x82, 0x2b, 0x26, 0x54, 0x3f, 0x0e, 0xbe, 0x88, 0xf3, 0x2a, 0x48, 0x9a, 0x56, 0x84, 0x3c, 0xd0, 0x4f, 0x03},
		[20]byte{0xed, 0x9d, 0x02, 0xe3, 0x82, 0xb3, 0x48, 0x18, 0xe8, 0x8b, 0x88, 0xa3, 0x09, 0xc7, 0xfe, 0x71, 0xe6, 0x5f, 0x41, 0x9d},
		2378237)
	if result {
		return false, errors.New("proof was not invalid as expected")
	}

	result = snark.VerifyUnshielding(proof,
		[32]byte{0x39, 0x2c, 0xeb, 0xa3, 0x2e, 0xf0, 0x24, 0x56, 0xd5, 0x19, 0xf0, 0x66, 0xe6, 0xb6, 0xf8, 0xa2, 0x72, 0xb6, 0x88, 0x4a, 0xb5, 0x73, 0x61, 0x58, 0xc6, 0x30, 0x8e, 0x04, 0x38, 0x2a, 0x78, 0xaf},
		[32]byte{0x88, 0x10, 0x65, 0x27, 0x39, 0xac, 0x0c, 0x6b, 0xb6, 0xb5, 0x35, 0x36, 0x49, 0xbb, 0x82, 0x2b, 0x26, 0x54, 0x3f, 0x0e, 0xbe, 0x88, 0xf3, 0x2a, 0x48, 0x9a, 0x56, 0x84, 0x3c, 0xd0, 0x4f, 0x03},
		[20]byte{0xed, 0x9d, 0x02, 0xe3, 0x82, 0xb3, 0x48, 0x18, 0xe8, 0x8b, 0x88, 0xa3, 0x09, 0xc7, 0xfe, 0x71, 0xe6, 0x5f, 0x41, 0x9d},
		2378237)
	if result {
		return false, errors.New("proof was not invalid as expected")
	}

	result = snark.VerifyUnshielding(proof,
		[32]byte{0x3a, 0x2c, 0xeb, 0xa3, 0x2e, 0xf0, 0x24, 0x56, 0xd5, 0x19, 0xf0, 0x66, 0xe6, 0xb6, 0xf8, 0xa2, 0x72, 0xb6, 0x88, 0x4a, 0xb5, 0x73, 0x61, 0x58, 0xc6, 0x30, 0x8e, 0x04, 0x38, 0x2a, 0x78, 0xaf},
		[32]byte{0x86, 0x10, 0x65, 0x27, 0x39, 0xac, 0x0c, 0x6b, 0xb6, 0xb5, 0x35, 0x36, 0x49, 0xbb, 0x82, 0x2b, 0x26, 0x54, 0x3f, 0x0e, 0xbe, 0x88, 0xf3, 0x2a, 0x48, 0x9a, 0x56, 0x84, 0x3c, 0xd0, 0x4f, 0x03},
		[20]byte{0xec, 0x9d, 0x02, 0xe3, 0x82, 0xb3, 0x48, 0x18, 0xe8, 0x8b, 0x88, 0xa3, 0x09, 0xc7, 0xfe, 0x71, 0xe6, 0x5f, 0x41, 0x9d},
		2378237)
	if result {
		return false, errors.New("proof was not invalid as expected")
	}

	return true, nil
}

// Test copied from from snark_test.go
func (api *PublicZSLAPI) DebugShieldedTransfer() (bool, error) {
	snark.Init()

	proof := snark.ProveTransfer(
		[32]byte{0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd},
		[32]byte{0xf0, 0xf0, 0xf0, 0xf0, 0x0f, 0x0f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0xf0, 0x00, 0x0f, 0x0f, 0x00, 0xf0, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0xff},
		2378237,
		0,
		[29][32]byte{
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00}},
		[32]byte{0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd, 0xde, 0xde, 0xff, 0xdd},
		[32]byte{0xf0, 0xf0, 0xf0, 0xf0, 0x0f, 0x0f, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0xf0, 0x00, 0x0f, 0x0f, 0x00, 0xf0, 0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0xff},
		2378237,
		0,
		[29][32]byte{
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00},
			{0x80, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x01, 0x00}},
		[32]byte{0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac},
		[32]byte{0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb},
		2378237,
		[32]byte{0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac},
		[32]byte{0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb, 0xac, 0xfb},
		2378237)

	result := snark.VerifyTransfer(proof,
		[32]byte{0x86, 0x10, 0x65, 0x27, 0x39, 0xac, 0x0c, 0x6b, 0xb6, 0xb5, 0x35, 0x36, 0x49, 0xbb, 0x82, 0x2b, 0x26, 0x54, 0x3f, 0x0e, 0xbe, 0x88, 0xf3, 0x2a, 0x48, 0x9a, 0x56, 0x84, 0x3c, 0xd0, 0x4f, 0x03},
		[32]byte{0x45, 0xcc, 0xb2, 0x10, 0x61, 0x33, 0x18, 0xd0, 0xd1, 0x27, 0xe9, 0x94, 0x7c, 0x2c, 0xe6, 0xb1, 0xb2, 0x46, 0xc5, 0xc2, 0xdd, 0x53, 0x48, 0x9c, 0x1f, 0x39, 0x39, 0x78, 0x43, 0x41, 0x0c, 0x1a},
		[32]byte{0x45, 0xcc, 0xb2, 0x10, 0x61, 0x33, 0x18, 0xd0, 0xd1, 0x27, 0xe9, 0x94, 0x7c, 0x2c, 0xe6, 0xb1, 0xb2, 0x46, 0xc5, 0xc2, 0xdd, 0x53, 0x48, 0x9c, 0x1f, 0x39, 0x39, 0x78, 0x43, 0x41, 0x0c, 0x1a},
		[32]byte{0x35, 0xf7, 0xff, 0x84, 0x5e, 0x47, 0x86, 0xd6, 0x44, 0xc9, 0xc9, 0x05, 0xfe, 0x68, 0xfd, 0x0f, 0x60, 0x2f, 0xea, 0x0b, 0xeb, 0x2c, 0x34, 0x1b, 0xc5, 0xd2, 0xde, 0xfc, 0x17, 0xc3, 0x2e, 0x86},
		[32]byte{0x35, 0xf7, 0xff, 0x84, 0x5e, 0x47, 0x86, 0xd6, 0x44, 0xc9, 0xc9, 0x05, 0xfe, 0x68, 0xfd, 0x0f, 0x60, 0x2f, 0xea, 0x0b, 0xeb, 0x2c, 0x34, 0x1b, 0xc5, 0xd2, 0xde, 0xfc, 0x17, 0xc3, 0x2e, 0x86},
		[32]byte{0xd6, 0x21, 0x8a, 0x07, 0x71, 0x4d, 0xd9, 0xfa, 0xc9, 0x2b, 0xde, 0xef, 0xd3, 0xf4, 0xc0, 0xd7, 0x69, 0xf4, 0x0f, 0x4b, 0x04, 0x3a, 0xd7, 0xe6, 0x7e, 0x73, 0x75, 0xed, 0xc4, 0x98, 0xe4, 0x5c},
		[32]byte{0xd6, 0x21, 0x8a, 0x07, 0x71, 0x4d, 0xd9, 0xfa, 0xc9, 0x2b, 0xde, 0xef, 0xd3, 0xf4, 0xc0, 0xd7, 0x69, 0xf4, 0x0f, 0x4b, 0x04, 0x3a, 0xd7, 0xe6, 0x7e, 0x73, 0x75, 0xed, 0xc4, 0x98, 0xe4, 0x5c})
	if !result {
		return false, errors.New("proof was not valid as expected")
	}

	result = snark.VerifyTransfer(proof,
		[32]byte{0x85, 0x10, 0x65, 0x27, 0x39, 0xac, 0x0c, 0x6b, 0xb6, 0xb5, 0x35, 0x36, 0x49, 0xbb, 0x82, 0x2b, 0x26, 0x54, 0x3f, 0x0e, 0xbe, 0x88, 0xf3, 0x2a, 0x48, 0x9a, 0x56, 0x84, 0x3c, 0xd0, 0x4f, 0x03},
		[32]byte{0x45, 0xcc, 0xb2, 0x10, 0x61, 0x33, 0x18, 0xd0, 0xd1, 0x27, 0xe9, 0x94, 0x7c, 0x2c, 0xe6, 0xb1, 0xb2, 0x46, 0xc5, 0xc2, 0xdd, 0x53, 0x48, 0x9c, 0x1f, 0x39, 0x39, 0x78, 0x43, 0x41, 0x0c, 0x1a},
		[32]byte{0x45, 0xcc, 0xb2, 0x10, 0x61, 0x33, 0x18, 0xd0, 0xd1, 0x27, 0xe9, 0x94, 0x7c, 0x2c, 0xe6, 0xb1, 0xb2, 0x46, 0xc5, 0xc2, 0xdd, 0x53, 0x48, 0x9c, 0x1f, 0x39, 0x39, 0x78, 0x43, 0x41, 0x0c, 0x1a},
		[32]byte{0x35, 0xf7, 0xff, 0x84, 0x5e, 0x47, 0x86, 0xd6, 0x44, 0xc9, 0xc9, 0x05, 0xfe, 0x68, 0xfd, 0x0f, 0x60, 0x2f, 0xea, 0x0b, 0xeb, 0x2c, 0x34, 0x1b, 0xc5, 0xd2, 0xde, 0xfc, 0x17, 0xc3, 0x2e, 0x86},
		[32]byte{0x35, 0xf7, 0xff, 0x84, 0x5e, 0x47, 0x86, 0xd6, 0x44, 0xc9, 0xc9, 0x05, 0xfe, 0x68, 0xfd, 0x0f, 0x60, 0x2f, 0xea, 0x0b, 0xeb, 0x2c, 0x34, 0x1b, 0xc5, 0xd2, 0xde, 0xfc, 0x17, 0xc3, 0x2e, 0x86},
		[32]byte{0xd6, 0x21, 0x8a, 0x07, 0x71, 0x4d, 0xd9, 0xfa, 0xc9, 0x2b, 0xde, 0xef, 0xd3, 0xf4, 0xc0, 0xd7, 0x69, 0xf4, 0x0f, 0x4b, 0x04, 0x3a, 0xd7, 0xe6, 0x7e, 0x73, 0x75, 0xed, 0xc4, 0x98, 0xe4, 0x5c},
		[32]byte{0xd6, 0x21, 0x8a, 0x07, 0x71, 0x4d, 0xd9, 0xfa, 0xc9, 0x2b, 0xde, 0xef, 0xd3, 0xf4, 0xc0, 0xd7, 0x69, 0xf4, 0x0f, 0x4b, 0x04, 0x3a, 0xd7, 0xe6, 0x7e, 0x73, 0x75, 0xed, 0xc4, 0x98, 0xe4, 0x5c})
	if result {
		return false, errors.New("proof was not invalid as expected")
	}

	return true, nil
}
